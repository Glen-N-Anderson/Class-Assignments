Glen Anderson
Homework #1
10/07/16

1. How did you decide what to test first? Would your final code change significantly if you changed the order of tests?
	To decide what to test first, I read over the assignment specifications and saw the instructor’s example test. Since the case of an empty string should be handled, I decided to write a test for this first. The test passed kwic an empty string, and kwic turned it into an empty list. The assert statement ensured that an empty list was returned. While the final code would not have been significantly altered by the early few tests, it certainly would have as they got more complicated. After the sixth test, the code was looking convoluted and out of order. I do not think the code would have changed much as far as the level of organization, but it would likely look different depending on what I did first. For example, I initially created the tuples within the list, forgetting for the time that they could not be changed once created. After being stuck on this for a while, I realized my mistake and had to restructure a lot of my code. In some ways, this “cheated” the spirit of test driven development but there was no other option short of scrapping all of my code and starting over. Because of this, I had to alter one of my tests retrospectively to test the list of strings itself instead of testing the overall structure of the large list containing tuples containing lists. I think more planning beforehand would have altered the result of the program, for example writing down a list of tests that the code should be able to eventually pass until the entire program was covered by tests, then actually implementing each test and writing the code accordingly. This would have made it easier to functionalize the programming as well, instead of having a repetitive and inefficient program. In this assignment, the development seemed restricted as all new code had the sole objective of getting a test to pass.

2. What did you think of test driven development, for this problem? What are the strengths and weaknesses of the approach? Does it encourage/discourage certain kinds of program designs?
This was my first time using test driven development, and at least early on in the assignment I could see its merits. However, for a problem that doesn’t have disastrous effects if it fails and is relatively simple to program, test driven development is tedious and unnecessary. I think some combination of test driven development and retrospective testing would be effective for complicated systems that need to work flawlessly.
The strengths of test driven development are that all code is covered by testing, code is thorough in accomplishing specifications, and the results are more likely to be airtight if not efficient. For problems that could have drastic consequences should the program fail, test driven development could be a good method of programming if used with other methods as well. With test-driven development, there is not much of a possibility of missing any specifications as the tests are written based on them.  
The largest weakness of test driven development is that it’s slow and limits the degree of testing that can be accomplished (assuming pure test-driven development). Having a developer write tests to cover every line of code before it is written takes longer than simply developing code, then testing it. The extent of the testing is limited to what the developer can think to test to write their next line of code, so some cases may be overlooked. In my experience it seemed to discourage functional programming designs and made code incredibly difficult to break up. However, this could be largely due to the fact that this was my first experience with test driven development. I think it encourages a thinking ahead approach to programming, where the programmer must anticipate tests that will run even in more advanced versions of their code. 
